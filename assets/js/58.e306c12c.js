(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{323:function(v,_,e){"use strict";e.r(_);var t=e(28),i=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"html中的插入位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html中的插入位置"}},[v._v("#")]),v._v(" HTML中的插入位置")]),v._v(" "),e("div",{staticClass:"storycontent"},[e("p",[v._v("该文章在Sciter2以上的behavior:richtext行为中有效。"),e("br"),v._v("\nbehavior:richtext行为时Sciter中"),e("code",[v._v("<richtext>")]),v._v("元素和Web浏览器中的"),e("code",[v._v("<div contenteditable>")]),v._v("的背后行为。")]),v._v(" "),e("p",[v._v("Sciter1中的behavior:richtext使用“flat”DOM模型: div:element, paragraph:element, 这个默写与Windows中的RichTextBox类似。"),e("br"),v._v("\n不过在Sciter2中，新的behavior:richtext行为使用标准的DOM模型，它的HTML内容为: element:node, text:node, comment:node。"),e("br"),v._v("\n这个变化导致我需要重新思考插入位置的概念。")]),v._v(" "),e("p",[v._v("  考虑下面的标记代码:")]),v._v(" "),e("pre",{staticClass:"brush: html"},[e("code",[v._v("<p>12<b>34</b><i>56</i></p>")]),v._v("\n")]),v._v(" "),e("p",[v._v("它的渲染结果如下: ")]),v._v(" "),e("p",[v._v("12"),e("b",[v._v("34")]),e("i",[v._v("56")])]),v._v(" "),e("p",[v._v("问题来了: 在这个段落中有多少个插入位置?")]),v._v(" "),e("p",[v._v("所有已知的内如可编辑实现都会给出这里有7个插入位置: 1前, 1和2之间, … 7后。所以他们都遵循了如Word或其他的所见即所得编辑工具的规范。")]),v._v(" "),e("p",[v._v('现在，考虑下这个任务, 将"AB"文本插入到段落中‘4’和‘5’之间，这时结果可能有以下几种:')]),v._v(" "),e("ol",[e("li",[e("code",[v._v("<b>")]),v._v("内部：12"),e("b",[v._v("34AB")]),e("i",[v._v("56,")]),v._v("  "),e("code",[v._v("12<b>34AB</b><i>56</i>")]),v._v(";")]),v._v(" "),e("li",[e("code",[v._v("<i>")]),v._v("内部：12"),e("b",[v._v("34")]),e("i",[v._v("AB56")]),v._v("  "),e("code",[v._v("12<b>34</b><i>AB56</i><p>")]),v._v(";")]),v._v(" "),e("li",[e("code",[v._v("<b>")]),v._v("和"),e("code",[v._v("<i>")]),v._v("之间: 12"),e("b",[v._v("34")]),v._v("AB"),e("i",[v._v("56")]),v._v("  "),e("code",[v._v("12<b>34</b>AB<i>56</i>")]),v._v(";")])]),v._v(" "),e("p",[v._v("问题正如我们所见: 一个(视觉)插入位置实际上最起码有3个(物理)DOM插入位置。")]),v._v(" "),e("p",[v._v('这是所见即所得编辑器实现的典型问题。在flat模型中，文本只是一个"样式化字符"的序列，所以这个问题不是一个主要问题。不过在HTML的所见即所得编辑器中，这个问题必须要想办法解决。')]),v._v(" "),e("p",[v._v('在Sciter1中，我使用了"有方向"的插入位置 – 物理插入位置取决于当前光标到达该插入位置的方向:')]),v._v(" "),e("ul",[e("li",[v._v("当你从右侧移动光标到当前位置时: "),e("code",[v._v("<b>3|4|</b><i>5|6|</i>")])]),v._v(" "),e("li",[v._v("当你从左侧移动光标到当前位置时"),e("code",[v._v("<b>|3|4</b><i>|5|6</i>")])])]),v._v(" "),e("p",[v._v("这种处理方式覆盖了上面的问题#1和#2，但是问题#3依然没有覆盖。所以还需要想想办法。")]),v._v(" "),e("p",[v._v("其实这个问题不仅仅是字符内部和跨文本才会出现，下面的这种情况也类似:")]),v._v(" "),e("pre",{staticClass:"brush: html"},[e("code",[v._v("<ul>\n  <li>一</li>\n  <li>二</li>\n</ul>\n<pre>一些代码</pre>")]),v._v("\n")]),v._v(" "),e("p",[v._v("这种情况下，如果你需要在列表的文本和<pre>块之间插入段落，你会怎么做:")]),v._v(" "),e("pre",{staticClass:"brush: html"},[e("code",[v._v("<ul>\n  <li>一</li>\n  <li>二</li>\n  </ul>\n  <p>一些文本</p>\n  <pre>一些代码</pre>")]),v._v("\n")]),v._v(" "),e("p",[v._v("你可以在你的浏览器中试一下:")]),v._v(" "),e("div",{staticStyle:{background:"#EEE",border:"1px dotted black"},attrs:{contenteditable:""}},[e("ul",[e("li",[v._v("一")]),v._v(" "),e("li",[v._v("二")])]),v._v(" "),e("pre",[e("code",[v._v("一些代码")])])])])])}),[],!1,null,null,null);_.default=i.exports}}]);