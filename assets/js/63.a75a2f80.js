(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{335:function(e,n,t){"use strict";t.r(n);var s=t(28),r=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"promises-a"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promises-a"}},[e._v("#")]),e._v(" Promises A+")]),e._v(" "),t("div",{staticClass:"post",attrs:{id:"post-41779"}},[t("h1",{staticClass:"storytitle"},[e._v("Sciter2中的Promises/A+ 实现")])]),e._v(" "),t("div",{staticClass:"storycontent"},[t("p",[e._v("Promises(诺言), 作为一个概念，它是一种通用的回调机制。现在，这种模式是非常流行的，所以Sciter2的SDK中也包含(sdk/samples/+promise/)了一个非常简单(60行代码)的Promises实现。")]),e._v(" "),t("p",[e._v("promise是一个对象:")]),e._v(" "),t("ol",[t("li",[e._v("1.通过"),t("code",[e._v(".then(onsuccess, onfailure)")]),e._v("方法维持了一对[onsuccess:function, onfailure:function]回调函数列/链表;")]),e._v(" "),t("li",[e._v('2.promise提供了一种方式来"execute"(执行)这个链表 - 或者是succes，或者是failure回调(如果发生错误);')]),e._v(" "),t("li",[e._v("3.链表中的每个回调函数会将上一个回调函数的输出((return [values]))作为一个输入参数(parameters)。")])]),e._v(" "),t("p",[e._v("在Sciter中，要创建一个promise，只需:")]),e._v(" "),t("pre",{staticClass:"brush: js;"},[t("code",[e._v("var oath = promise();")])]),e._v(" "),t("h3",[e._v("promise()函数 与 promise 对象")]),e._v(" "),t("p",[e._v("在我的实现中，promise()函数返回一个函数/对象，它拥有一个.then()方法。所以要为promise附加回调函数，你可以:")]),e._v(" "),t("pre",{staticClass:"brush: js;"},[t("code",[e._v('oath.then( function( data ) { return [data+1] } ) // #1\n    .then( function( data ) { return [data+2] } ) // #2\n    .then( function( data ) { stdout.println("success:", data)}, // #3 \n           function( reason ) { stderr.println("error:", reason)} );')]),e._v("\n")]),e._v(" "),t("p",[e._v("现在，我们有一个名称为oath的promise变量，它有三个onsuccess函数。")]),e._v(" "),t("p",[e._v("要履行promise(承诺)时, 我们只需调用promise(将它作为一个函数)，将它的第一个参数设置true，其他参数将会传递到链中的第一个回调函数:")]),e._v(" "),t("pre",{staticClass:"brush: js;"},[t("code",[e._v("oath(true, 1);")])]),e._v(" "),t("p",[e._v("将会调用第一个回调函数，且data参数值为1，并且该回调函数返回1 + 1 -> 2。"),t("br"),e._v("\n值2将会传递到第二个回调函数上，并且返回2 + 2 -> 4。"),t("br"),e._v("\n\t最终的回调函数返回:")]),e._v(" "),t("pre",[t("code",[e._v("success:4")])]),e._v(" "),t("p",[e._v("要拒绝promise(承诺)时，我们只需调用promise(将它作为一个函数)，将它的第一个参数设置false:")]),e._v(" "),t("pre",{staticClass:"brush: js;"},[t("code",[e._v('oath(false, "something went wrong!");')])]),e._v(" "),t("p",[e._v("这样讲调用我们的onerror回调函数，结果为:")]),e._v(" "),t("pre",[t("code",[e._v("error: something went wrong!")])]),e._v(" "),t("h3",[e._v("promise.when()函数, 并行执行")]),e._v(" "),t("p",[e._v("promise也定义了一个promise.when(...)静态函数，它接受一个promise列表，并且返回另一个promise，当所有输入promise将完成时，该promise将被履行/拒绝。")]),e._v(" "),t("pre",{staticClass:"brush: js;"},[t("code",[e._v("function printBandC(b,c) { stdout.println(b,c) }\nvar BandC = \n    promise.when( self.request(#get-json, urlB),\n                  self.request(#get-json, urlC)).then(printBandC);\n")])]),e._v(" "),t("p",[e._v("关于这个内容有很多文章, 只需要在谷歌中搜索“Promises JavaScript”")]),e._v(" "),t("p",[e._v("这里是promise.tis模块的全部源代码:")]),e._v(" "),t("p",[t("span",{attrs:{id:"more-41779"}})]),e._v(" "),t("pre",{staticClass:"brush: js;"},[t("code",[e._v("//|   \n//| Promises/A+ 规范的实现: http://promises-aplus.github.io/promises-spec/\n//| \nfunction promise() \n{\n  var state = null;    // null = pending, true = fulfilled, false = rejected\n  var deferred = [];   // functions to call when _promise() is invoked\n  var values = [];     // an array of values as arguments for the then() handlers\n  function _promise(newState, newValues) \n  {\n    if (state === null) {\n      state = newState;\n      values = newValues;\n      self.post( function() { for (var d in deferred) d() } );\n    }\n  }\n  _promise.then = function(onFulfilled, onRejected = null) \n  {\n    var newPromise = promise();\n    function notify() \n    {\n      try {\n        var f = state ? onFulfilled : onRejected;\n        if (typeof f == #function) {\n          var r = f.apply(null, values);\n          if (r && typeof r.then == #function) // looks like it is a promise to, chain them\n            r.then( function(args..){ newPromise(true,args) }, \n                    function(args..){ newPromise(false,args) } );\n          else\n            newPromise(true, [r]);\n        }\n        else\n          newPromise(state, values);\n      }\n      catch (e) {\n        newPromise(false, [e]);\n      }\n    }\n    if (state !== null) \n      self.post(notify); // already fullfilled/failed\n    else\n      deferred.push(notify);      \n    return newPromise;\n  };\n  return _promise;\n}\npromise.when = function (args..) \n{\n  if(args.length == 1) return args[0];\n  var oath = promise();\n  var n = args.length;\n  var res = [];\n  function done(i) { return function(v) { res[i] = v; if(--n == 0) oath(true,res); } }\n  function fail(v) { oath(false,v) }\n  for(var (i,ip) in args) \n      ip.then(done(i), fail);\n  return oath;\n};\n// This makes first parameter of Element.request optional: \n// Element.request( [callback: function | integer,] \n//                  #get | #post | #post-data | #put-data | #post-json | #put-json | #delete, \n//                  url: string \n//                  [, params: object [, headers: object] ] ) : Object | Stream | Bytes | Error\n// If callback is omitted the method returns promise: \n(function(){\n  var ElementRequest = Element.request;\n  // redefining Element.request function\n  Element.request = function(args..) {\n    if(typeof args[0] == #function || typeof args[0] == #integer)\n      return ElementRequest.apply(this,args); // standard call\n    // call without callback, send request and return the promise\n    var oath = promise();\n    ElementRequest.apply(this, function(data,status) \n                              { oath(status == 200, [data,status]); }, args );\n    return oath;\n  }\n})();  ")]),e._v("\n")])])])}),[],!1,null,null,null);n.default=r.exports}}]);