(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{304:function(t,o,r){"use strict";r.r(o);var a=r(28),n=Object(a.a)({},(function(){var t=this,o=t.$createElement,r=t._self._c||o;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"formation库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#formation库"}},[t._v("#")]),t._v(" Formation库")]),t._v(" "),r("h2",{attrs:{id:"mvc-或-非mvc-jquery的formation引擎"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mvc-或-非mvc-jquery的formation引擎"}},[t._v("#")]),t._v(" MVC 或 非MVC? jQuery的Formation引擎")]),t._v(" "),r("div",{staticClass:"storycontent"},[r("p",[t._v("现在，有很多JavaScript框架提供了数据绑定工具(如Knockout、AngularJS等)。")]),t._v(" "),r("p",[t._v("它们基于一种MVC概念: 你有一些数据(M)(结构、模型), 视图(V)展示html中的数据，在模型和视图间还有一些名为控制器(C)的代码来控制它们间的交互。")]),t._v(" "),r("p",[t._v("基于上面所说的概念设计的那些框架确实是挺成功/方便的，不过，对我来说它们又是太侵入性了。在一些视图/页面上使用MVC是可以理解的，但是在一些其他的解决方案里MVC看起来太丑陋了。")]),t._v(" "),r("p",[t._v("不管怎样，这里给出了另一种可选方案…")]),t._v(" "),r("p",[t._v("我们不是将数据结构和它的视图分离，而是创建一个新的东西，它既是数据模型也是它的视图。")]),t._v(" "),r("p",[t._v("我将这个东西名称成Formation。Formation本质上是一个DOM元素的树形容器，这个容器可以复制数据的结构 (你也可以称它为模型)。Formation的值是JSON数据结构。")]),t._v(" "),r("p",[t._v("考虑这个"),r("a",{attrs:{href:"http://terrainformatica.com/formation/demo1.htm"}},[t._v("示例")])]),t._v(" "),r("p",[t._v("这里你可以看到input和子项的集合(顶部)。"),r("br"),t._v("\n   在右下脚，你可以看到<section#inputs>创建的Formation树。")]),t._v(" "),r("p",[t._v("左边，你可以看到Formation的动态数据(可编辑的textarea)。这个这些数据会将它们反应到对应的DOM元素的状态上。同样，修改这些DOM元素也会反应到这些动态数据上。")]),t._v(" "),r("p",[t._v("Formation的实现主要做了两件事情: ")]),t._v(" "),r("ul",[r("li",[t._v("1. 创建formation树;")]),t._v(" "),r("li",[t._v("2. 初始化自定义DOM元素(定义在HTML源码中)。")])]),t._v(" "),r("p",[t._v("formations支持两组自定义元素的关键字:")]),t._v(" "),r("p",[t._v("当formation看到自定义DOM元素(Tag标签中包含‘-‘的任何DOM元素)，它尝试从jQuery插件的注册表中找到该元素的初始化器(著名的$.fn集合)，如果找到了则调用它。你可以检查js/jquery.list-input.js - 这是一个正常的jQuery插件，该插件匹配名称为“INPUT-LIST”的自定义元素。")]),t._v(" "),r("p",[t._v("为了创建/获取一些容器的formation，你可以调用：")]),t._v(" "),r("ol",[r("li",[t._v("global "),r("code",[t._v("[window.] formation( domel_or_$_wrapper )")]),t._v(" 函数， 或")]),t._v(" "),r("li",[r("code",[t._v("$(selector).formation()")]),t._v(" 插件。")])]),t._v(" "),r("p",[t._v("你可以将创建的formation存储到一些变量中，并且通过它来访问DOM元素，这是一个非常有效的手段:")]),t._v(" "),r("pre",[r("code",[t._v('var inputs = $("section#inputs").formation();\n$(inputs.firstName).on("change", function(){...});\n')])]),t._v(" "),r("p",[t._v("直接访问formation的成员比通过jQuery选择器访问它们的速度更快，因为formation的成员直接是该元素的一个引用。")]),t._v(" "),r("p",[t._v("你可以从"),r("a",{attrs:{href:"http://terrainformatica.com/formation/formation.0.1.0.zip"}},[t._v("这里")]),t._v("下载完整示例来演示看看。")]),t._v(" "),r("p",[t._v("Formation的未来计划: 实现所谓的repeatable formations, 这时，如果你有下面的标记代码:")]),t._v(" "),r("div",[r("pre",[r("code",[t._v('<ul repeatable name="stockItems">\n  <li><output name="name">  <output name="price" type="price"></li>\n</ul>\n')])]),t._v(" "),r("p",[t._v("则你可以通过下面的数据来反馈它(通过formation):")]),t._v(" "),r("pre",[r("code",[t._v('[\n  {name:"Apple", price: 1.05 },\n  {name:"Orange", price: 0.52 }\n]\n')])]),t._v(" "),r("p",[t._v("它将会在ul列表中生成两个<li>元素。")]),t._v(" "),r("p",[t._v("有另一种不鼓励的想法：将有class开关的作为一个Formation元素，请看下面的class声明:")]),t._v(" "),r("pre",[r("code",[t._v('<div class="{someSwitch:collapsed|expanded}" >...</div>\n')])]),t._v(" "),r("p",[t._v("将会是对应的formation有一个名称为“someSwitch”元素，该元素的值可以被设置false/true或0/1来改变class为<div class=”collapsed”>或<div class=”expanded”>。")]),t._v(" "),r("p",[t._v("更新: 请看jQuery论坛的相关讨论: "),r("a",{attrs:{href:"http://forum.jquery.com/topic/mvc-or-not-mvc-the-formation-engine"}},[t._v("forum.jquery.com/topic/mvc-or-not-mvc-the-formation-engine")])])])])])}),[],!1,null,null,null);o.default=n.exports}}]);