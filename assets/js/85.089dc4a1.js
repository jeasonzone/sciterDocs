(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{373:function(e,i,v){"use strict";v.r(i);var n=v(28),t=Object(n.a)({},(function(){var e=this,i=e.$createElement,v=e._self._c||i;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"visibility的none值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#visibility的none值"}},[e._v("#")]),e._v(" visibility的none值")]),e._v(" "),v("p",[e._v("在基于HTML/CSS的UI中，我们经常需要在运行期隐藏/显示一些元素。")]),e._v(" "),v("p",[e._v("最普遍的可能(也是最差的)的解决方法是以编程方式设置CSS属性"),v("code",[e._v("display:none")]),e._v("。")]),e._v(" "),v("p",[e._v("这个方法乍一看好像非常简单，但实际上它只解决了一半的问题——隐藏元素——从视图树上移除这个元素。但是，当你需要显示之前隐藏的元素时，你又该怎么做呢? 设置它为"),v("code",[e._v("display:block")]),e._v("不是一个正确的方法。在HTML中不是所有的元素都是display:block模型。 <img>、<input>//<select>、<textarea>等是"),v("code",[e._v("display:inline-block")]),e._v("模型。 <table>和它的所有子元素都是特殊的display:table**** 模型。设置它们为"),v("code",[e._v("display:block")]),e._v("将会导致出现非常奇怪的结果。")]),e._v(" "),v("p",[e._v("因此，为了在运行期使用"),v("code",[e._v("display:none")]),e._v("，你需要知道这个元素的display原始值，这不是很方便且不易维护。设想当你的web设计器打算通过声明"),v("code",[e._v("display: table-cell")]),e._v("来摆放一些元素时，如果你是通过 display: none <-> block开关来控制元素的隐藏/显示时，这时你会遇到问题。")]),e._v(" "),v("p",[e._v('例如，为了克服这样的问题，jQuery通过将display值存储在一个名为"olddisplay"的属性方式实现了它的'),v("code",[e._v("hide()")]),e._v("方法(参见: http://robflaherty.github.io/jquery-annotated-source/docs/13-effects.html#section-6 )，当你需要重新显示这个元素时，jQuery从这个属性恢复display值。因某些很明显的原因，这个方法也不是很理想。")]),e._v(" "),v("h2",[e._v("更好的办法")]),e._v(" "),v("p",[e._v('更好的办法是使用"hidden"属性。所以当你需要隐藏元素时，不是设置CSS属性element.style.display，而是为元素添加DOM属性"hidden"，当需要显示元素时，移除"hidden"属性。为了使这个属性有效，你只需在你的样式表中添加一个简单的规则:')]),e._v(" "),v("pre",[v("code",[e._v("[hidden] { display:none !important; }\n")])]),e._v(" "),v("p",[e._v("如果某些元素需要默认隐藏，你需要在你的标记代码中添加hidden属性，如:"),v("br")]),e._v(" "),v("pre",[v("code",[e._v('<button id="ok-button" hidden>OK</button>\n')])]),e._v(" "),v("p",[e._v('在Sciter中，你可以为所有的DOM元素定义一些虚拟的属性, 如"shown":')]),e._v(" "),v("pre",[v("code",[e._v('/* 要保证下面的代码有效，CSS中必须有[hidden] { display:none } 规则 */\nproperty Element.shown(v) \n{\n  get return this.style#display != "none";\n  set this.attributes["hidden"] = v ? undefined : true;\n}\n')])]),e._v(" "),v("p",[e._v("并且这样使用它：")]),e._v(" "),v("pre",[v("code",[e._v("var someEl = ..."),v("br"),v("br"),e._v("someEl.shown = true; // 显示"),v("br"),e._v("someEl.shown = false; // 隐藏\n")])]),e._v(" "),v("p",[e._v("这个解决办法有个不明显的缺点: ")]),e._v(" "),v("ol",[v("li",[e._v("你需要在你的CSS中添加特殊的"),v("code",[e._v("[hidden] { display:none; }")]),e._v("规则;")]),e._v(" "),v("li",[e._v('在所有场景，当你需要显示/隐藏元素时，你需要使用特殊的"shown"属性或显示地移除元素的"hidden"属性。')])]),e._v(" "),v("h2",[e._v("visibility:none")]),e._v(" "),v("p",[e._v("从Sciter 3.1.0.15版本开始，你可以在你的CSS中使用"),v("code",[e._v("visibility:none;")]),e._v("来排除某个元素的渲染。它与"),v("code",[e._v("display:none;")]),e._v("有相同的效果。")]),e._v(" "),v("p",[e._v('visibility属性可以使你不用使用dsiplay属性，安全地设置"none"和"visible"值来达到显示/隐藏元素的效果。')]),e._v(" "),v("p",[e._v("因此, Sciter中，"),v("strong",[e._v("visibility")]),e._v("属性可以接受以下值:")]),e._v(" "),v("ul",[v("li",[v("em",[e._v("none")]),e._v(" - 元素从显示树中移除，等同于display:none，Sciter特有值;")]),e._v(" "),v("li",[v("em",[e._v("hidden")]),e._v(" - 元素在显示树中，占据空间，但是不显示;")]),e._v(" "),v("li",[v("em",[e._v("collapse")]),e._v(" - 元素在显示树中，占据空间，但是它的高度和宽度会堆叠成0。如在flow:horizontal容器中，visibility:collapse的子元素将会占据垂直空间，但显示宽度将设置为0。在Sciter中，这个值对所有元素都有效，但是在标准CSS中，它只对表格(table)的行(tr)元素有效。")]),e._v(" "),v("li",[v("em",[e._v("visible")]),e._v(" - 默认值, 元素正常的显示。")])]),e._v(" "),v("p",[e._v("下面是上面定义的脚本属性shown的修改版本:")]),e._v(" "),v("pre",[v("code",[e._v('property Element.shown(v) \n{\n  get return this.isVisible;\n  set this.style#visibility = v ? "visible" : "none";\n} \n')])]),e._v(" "),v("p")])}),[],!1,null,null,null);i.default=t.exports}}]);