(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{354:function(t,e,s){"use strict";s.r(e);var c=s(28),i=Object(c.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"behavior与prototype-aspect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#behavior与prototype-aspect"}},[t._v("#")]),t._v(" behavior与prototype/aspect")]),t._v(" "),s("div",[s("h1",{staticClass:"storytitle"},[t._v("Behavior与CSS中的prototype/aspect属性")])]),t._v(" "),s("div",{staticClass:"storycontent"},[s("p",[t._v("从一开始，Sciter就支持将一个声明的脚本类附加到DOM元素上。")]),t._v(" "),s("p",[t._v("如果你想使你的文档中的所有div.some-widget元素都拥有一些特别的行为(子类化), 你需要:")]),t._v(" "),s("p",[t._v("1. 在脚本中声明 ")]),t._v(" "),s("pre",{staticClass:"brush: js;"},[s("code",[t._v("class SomeWidget : Behavior {\n  function attached() { ... } // 该方法中的'this'为子类化的DOM元素\n  function detached() { ... }\n  // ... SomeWidget特有的方法在这里指定\n}")])]),t._v(" "),s("p",[t._v("2. 在CSS中声明 ")]),t._v(" "),s("pre",{staticClass:"brush: css;"},[s("code",[t._v("div.some-widget { behavior:SomeWidget; } \n/* 或者，如果SomeWidget的声明在其他文件中: */\ndiv.some-widget { SomeWidget url(some-widget.tis); }")])]),t._v(" "),s("p",[t._v("在上面的声明中，所有的有class=”some-widget”的div都将被附加了SomeWidget类。这个机制我已经在8年前讲过了。")]),t._v(" "),s("p",[t._v("这个机制是很可靠的，也是非常方便的。")]),t._v(" "),s("p",[t._v("behaviors/prototypes的唯一问题是 – 在给定时刻，一个DOM元素只能有一个脚本类。JavaScript和TIScript都不支持多层继承。")]),t._v(" "),s("p",[t._v("设想一下，在脚本中，你有多个函数要为某些DOM元素指定一些特定的功能。")]),t._v(" "),s("p",[t._v("或者说，每个这样的函数添加到被调用的DOM元素自己的aspect (部分功能)。类似下面:")]),t._v(" "),s("pre",{staticClass:"brush: js;"},[s("code",[t._v('function addClickHandlerFor(element) {\n  // ͨ通过html中的"click"元素的属性添加onClick处理器\n  element.on("click", function() { \n    var attrClick = element.attributes["click"];  \n    element.eval(attrClick); // 对表达式进行求值\n  });\n}')])]),t._v(" "),s("p",[t._v("你可以有一个这样的函数集来配置不同的元素/行为的aspect。")]),t._v(" "),s("p",[t._v("上面的流程是原则上的，不过你可能需要为你需要这样配置的元素显示的调用这些函数，同时不用忘了为动态创建的内容调用它们。")]),t._v(" "),s("p",[t._v("考虑上面的这些情况，我为Sciter引入了特有的CSS属性——‘aspect’。")]),t._v(" "),s("h4",[t._v("The "),s("code",[t._v("aspect")]),t._v(" CSS property")]),t._v(" "),s("p",[t._v("它的声明为 ")]),t._v(" "),s("pre",[s("code",[t._v('\naspect: "函数名" [ url(of-function-implementation-file) ];\n')])]),t._v(" "),s("p",[t._v('其中，"函数名"是一个“aspect”函数的全名，指为DOM元素配置/装载额外功能的函数。 其中的url()是定义该函数的文件名。')]),t._v(" "),s("p",[t._v("aspect处理原则:")]),t._v(" "),s("p",[t._v("“aspect”函数时一个普通的tiscript脚本函数。")]),t._v(" "),s("ol",[s("li",[t._v("1.其中的this变量指向满足CSS规则的DOM元素。")]),t._v(" "),s("li",[t._v("2.在DOM元素的生命周期内只会执行一次。")])]),t._v(" "),s("p",[t._v("ͬ同时, aspect属性使用非标准的继承性 – 如果元素有多个CSS匹配规则中都定义了aspect，则该元素所使用的aspect是所有这些规则定义的aspect列表。因此，如果你有下面的规则 (来自Plus引擎的示例):")]),t._v(" "),s("pre",{staticClass:"brush: css;"},[s("code",[t._v('[click] { aspect:"Plus.Click"; }\n[dblclick] { aspect:"Plus.DblClick"; }\n')])]),t._v(" "),s("p",[t._v("同时，元素在html标志中的定义如下：")]),t._v(" "),s("pre",{staticClass:"brush: html;"},[s("code",[t._v('<b id="clickable" click="..." dblclick="...">text</b>')])]),t._v(" "),s("p",[t._v("它将拥有两个调用函数 – Plus.Click() 和 Plus.DblClick()。等同于下面的CSS定义:")]),t._v(" "),s("pre",{staticClass:"brush: css;"},[s("code",[t._v('#clickable { aspect:"Plus.Click" "Plus.DblClick"; }\n')])]),t._v(" "),s("p",[t._v("这个aspect机制在Sciter SDK中的Plus ( /samples/+plus/ ) 和 Lang ( /samples/+lang/ )引擎中已经在使用了。"),s("br"),t._v("\nPlus提供了类似AngularJS的声明式数据绑定功能。Lang提供了对i18n的支持。")])])])}),[],!1,null,null,null);e.default=i.exports}}]);