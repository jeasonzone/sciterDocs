(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{272:function(v,_,d){"use strict";d.r(_);var e=d(28),o=Object(e.a)({},(function(){var v=this,_=v.$createElement,d=v._self._c||_;return d("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[d("h1",{attrs:{id:"regexp-正则表达式"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#regexp-正则表达式"}},[v._v("#")]),v._v(" RegExp(正则表达式)")]),v._v(" "),d("p",[v._v("代表编译后的正则表达式。")]),v._v(" "),d("p",[v._v("支持的正则表达式语法:")]),v._v(" "),d("dl",[d("h2",[v._v("规则")]),v._v(" "),d("dt",[v._v("字符")]),v._v(" "),d("dd",[v._v("含义")]),v._v(" "),d("dt",[d("code",[v._v("\\")])]),v._v(" "),d("dd",[d("p",[v._v("该字符指示将下一个字符标记为一个特殊字符。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/b/")]),v._v("匹配字符'b'。通过在'b'前放置一个反斜杠字符，即"),d("code",[v._v("/\\b/")]),v._v("，则该字符就匹配一个单词边界。")]),v._v(" "),d("p",[d("em",[v._v("或者")])]),v._v(" "),d("p",[v._v("该字符也通常用于指示下一个字符不是特殊字符，即只需直接按字面意思翻译即可。")]),v._v(" "),d("p",[v._v("例如, *是一个特殊字符，它的意思是匹配*号前面的字符出现0个或多个的情况。如"),d("code",[v._v("/a*/")]),v._v('意思是匹配0个或多个"a"。若为了匹配'),d("code",[v._v("*")]),v._v("字符, 则在它前面放一个反斜杠；如"),d("code",[v._v("/a\\*/")]),v._v("会匹配'a*'。")])]),v._v(" "),d("dt",[d("code",[v._v("^")])]),v._v(" "),d("dd",[d("p",[v._v("匹配输入字符串的开始位置。如果设置了 RegExp 对象的Multiline属性，^也匹配'\\n'或'\\r'(换行)之后的位置。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/^A/")]),v._v("不会匹配\"an A\"中的'A', 但是会匹配\"An A.\"中的第一个'A'。")])]),v._v(" "),d("dt",[d("code",[v._v("$")])]),v._v(" "),d("dd",[d("p",[v._v("匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$也匹配'\\n'或'\\r'(换行)之前的位置。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/t$/")]),v._v("不会匹配\"eater\"中的't', 但是会匹配\"eat\"中的't'。")])]),v._v(" "),d("dt",[d("code",[v._v("*")])]),v._v(" "),d("dd",[d("p",[v._v("匹配*前面的子表达式0次或多次。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/bo*/")]),v._v('会匹配"A ghost booooed"中的\'boooo\'和"A bird warbled"中的\'b\', 但是不会匹配"A goat grunted"。')])]),v._v(" "),d("dt",[d("code",[v._v("+")])]),v._v(" "),d("dd",[d("p",[v._v("匹配前面的子表达式一次或多次。等价于"),d("code",[v._v("{1,}")]),v._v("。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/a+/")]),v._v("匹配\"candy\"中的'a'和\"caaaaaaandy\"中的'aaaaaaa'。")])]),v._v(" "),d("dt",[d("code",[v._v("?")])]),v._v(" "),d("dd",[d("p",[v._v("匹配前面的子表达式0次或1次。等价于 {0,1}")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/e?le?/")]),v._v("会匹配\"angel\"中的'el'和\"angle.\"中的'le'。")]),v._v(" "),d("p",[v._v("注意：当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \"oooo\"，'o+?' 将匹配单个 \"o\"，而 'o+' 将匹配所有 'o'。")]),v._v(" "),d("p",[v._v("也用于前瞻断言，如"),d("code",[v._v("(?=)")]),v._v(", "),d("code",[v._v("(?!)")]),v._v(", and "),d("code",[v._v("(?:)")]),v._v("。")])]),v._v(" "),d("dt",[d("code",[v._v("x{n}")])]),v._v(" "),d("dd",[d("p",[v._v("其中n是一个正整数。匹配n次出现的前一项x。")]),v._v(" "),d("p",[v._v('比如, /a{2}/ 讲不会匹配"candy"中的"a", 但是它将匹配"caandy"中出现的所有"a", 以及"caaandy"中的第一个两个"a"。')])]),v._v(" "),d("dt",[d("code",[v._v("x{n,}")])]),v._v(" "),d("dd",[d("p",[v._v("其中n是一个正整数。匹配至少n次出现的前一项x。")])]),v._v(" "),d("dt",[d("code",[v._v("x{n,m}")])]),v._v(" "),d("dd",[d("p",[v._v("其中n和m是一个正整数。 匹配至少n次最多m次出现的前一项x。")])]),v._v(" "),d("dt",[d("code",[v._v(".")])]),v._v(" "),d("dd",[d("p",[v._v("匹配除\"\\n\"、\\r、\\u2028、\\u2029之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' 的模式。("),d("code",[v._v("[\\s\\S]")]),v._v("可以匹配任意字符，包括换行符号)")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/.n/")]),v._v("匹配\"nay, an apple is on the tree\"中的'an'和'on' , 但是不会匹配'nay'。")])]),v._v(" "),d("dt",[d("code",[v._v("{n}")])]),v._v(" "),d("dd",[d("p",[v._v("n 是一个非负整数。匹配确定的 n 次。")]),v._v(" "),d("p",[v._v("例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。")])]),v._v(" "),d("dt",[d("code",[v._v("{n,}")])]),v._v(" "),d("dd",[d("p",[v._v("n 是一个非负整数。至少匹配n 次。")]),v._v(" "),d("p",[v._v("例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。")])]),v._v(" "),d("dt",[d("code",[v._v("{n,m}")])]),v._v(" "),d("dd",[d("p",[v._v("m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。")]),v._v(" "),d("p",[v._v("例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。")])]),v._v(" "),d("dt",[d("code",[v._v("(x)")])]),v._v(" "),d("dd",[d("p",[v._v("匹配"),d("code",[d("em",[v._v("x")])]),v._v("并记住这一匹配。这称为捕获括号。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/(foo)/")]),v._v("匹配并记住\"foo bar.\"中的'foo'。可以从结果数组中使用"),d("code",[v._v("[1], ..., [n]")]),v._v("或者从定义的"),d("code",[v._v("RegExp")]),v._v("对象的"),d("code",[v._v("$1, ..")]),v._v("属性中调用被匹配的字符串。")])]),v._v(" "),d("dt",[d("code",[v._v("(x?=y)")])]),v._v(" "),d("dd",[d("p",[v._v("仅当"),d("i",[v._v("x")]),v._v("后面跟着"),d("i",[v._v("y")]),v._v("时才匹配"),d("i",[v._v("x")]),v._v("。")])]),v._v(" "),d("dt",[d("code",[v._v("x(?!y)")])]),v._v(" "),d("dd",[d("p",[v._v("仅当"),d("i",[v._v("x")]),v._v("后面跟着不是"),d("i",[v._v("y")]),v._v("时才匹配"),d("i",[v._v("x")]),v._v("。")])]),v._v(" "),d("dt",[d("code",[v._v("x|y")])]),v._v(" "),d("dd",[d("p",[v._v("匹配"),d("code",[d("em",[v._v("x")])]),v._v("或"),d("code",[d("em",[v._v("y")])]),v._v("。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/green|red/")]),v._v("会匹配\"green apple\"中的'green'和\"red apple\"中的'red'。")])]),v._v(" "),d("dt",[d("code",[v._v("[xyz]")])]),v._v(" "),d("dd",[d("p",[v._v("字符集合。匹配所包含的任意一个字符。")]),v._v(" "),d("p",[v._v("例如， '[abc]' 可以匹配 \"plain\" 中的 'a'。")])]),v._v(" "),d("dt",[d("code",[v._v("[^xyz]")])]),v._v(" "),d("dd",[d("p",[v._v("负值字符集合。匹配未包含的任意字符。")]),v._v(" "),d("p",[v._v("例如，'[^abc]' 可以匹配 \"plain\" 中的'p'。")])]),v._v(" "),d("dt",[d("code",[v._v("[a-z]")])]),v._v(" "),d("dd",[d("p",[v._v("字符范围。匹配指定范围内的任意字符。")]),v._v(" "),d("p",[v._v("例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。")])]),v._v(" "),d("dt",[d("code",[v._v("[^a-z]")])]),v._v(" "),d("dd",[d("p",[v._v("负值字符范围。匹配任何不在指定范围内的任意字符。")]),v._v(" "),d("p",[v._v("例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符")])]),v._v(" "),d("dt",[d("code",[v._v("(?:x)")])]),v._v(" "),d("dd",[d("p",[v._v('匹配x但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。')]),v._v(" "),d("p",[v._v("例如，'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。")])]),v._v(" "),d("dt",[d("code",[v._v("(?=x)")])]),v._v(" "),d("dd",[d("p",[v._v("正向预查，在任何匹配x的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。")]),v._v(" "),d("p",[v._v('例如，\'Windows (?=95|98|NT|2000)\' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。')])]),v._v(" "),d("dt",[d("code",[v._v("(?!x)")])]),v._v(" "),d("dd",[d("p",[v._v("负向预查，在任何不匹配x的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。")]),v._v(" "),d("p",[v._v('例如\'Windows (?!95|98|NT|2000)\' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始')])]),v._v(" "),d("dt",[d("code",[v._v("\\b")])]),v._v(" "),d("dd",[d("p",[v._v("匹配一个单词边界，也就是指单词和空格间的位置(不要与"),d("code",[v._v("[\\b]")]),v._v("混淆)。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/\\bn\\w/")]),v._v("匹配\"noonday\"中的'no'，而"),d("code",[v._v("/\\wy\\b/")]),v._v("匹配\"possibly yesterday\"中的'ly'。")])]),v._v(" "),d("dt",[d("code",[v._v("\\B")])]),v._v(" "),d("dd",[d("p",[v._v("匹配非单词边界。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/\\w\\Bn/")]),v._v("匹配\"noonday\"中的'on'，而"),d("code",[v._v("/y\\B\\w/")]),v._v("匹配quot;possibly yesterday\"中的'ye'。")])]),v._v(" "),d("dt",[d("code",[v._v("\\d")])]),v._v(" "),d("dd",[d("p",[v._v("匹配一个数字字符。等价于 [0-9]。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/\\d/")]),v._v("或"),d("code",[v._v("/[0-9]/")]),v._v("匹配\"B2 is the suite number\"中的'2'。")]),v._v(" "),d("p",[d("b",[v._v("注意:")]),v._v(" 它与JavaScript中的\\d不同的，在JS中，\\d仅匹配[0-9]字符。")])]),v._v(" "),d("dt",[d("code",[v._v("\\D")])]),v._v(" "),d("dd",[d("p",[v._v("匹配一个非数字字符。等价于 [^0-9]。")]),v._v(" "),d("p",[v._v("例如, "),d("code",[v._v("/\\D/")]),v._v("或"),d("code",[v._v("/[^0-9]/")]),v._v("匹配\"B2 is the suite number\"中的'B'。")])]),v._v(" "),d("dt",[d("code",[v._v("\\a")])]),v._v(" "),d("dd",[d("p",[v._v("匹配一个字母字符。")])]),v._v(" "),d("dt",[d("code",[v._v("\\A")])]),v._v(" "),d("dd",[d("p",[v._v("匹配一个非字母字符。")])]),v._v(" "),d("dt",[d("code",[v._v("\\w")])]),v._v(" "),d("dd",[d("p",[v._v("匹配任意来自字母表的字母和数字字符。")]),v._v(" "),d("p",[d("b",[v._v("注意:")]),v._v(" 它与JavaScript中的不同，在JS中\\w仅匹配ASCII字符和数字。")])]),v._v(" "),d("dt",[d("code",[v._v("\\W")])]),v._v(" "),d("dd",[d("p",[v._v("匹配任意非来自字母表的字母和数字字符。")])]),v._v(" "),d("dt",[d("code",[v._v("\\s")])]),v._v(" "),d("dd",[d("p",[v._v("匹配任意来自字母表的空白字符。")])]),v._v(" "),d("dt",[d("code",[v._v("\\S")])]),v._v(" "),d("dd",[d("p",[v._v("匹配非任意来自字母表的空白字符。")])])]),v._v(" "),d("h2",[v._v("属性")]),v._v(" "),d("dl",[d("dt",[v._v("length")]),v._v(" "),d("dd",[v._v("- "),d("em",[v._v("integer")]),v._v(", 在最后一次调用"),d("em",[v._v("exec")]),v._v("或"),d("em",[v._v("match")]),v._v("方法后的匹配数量。")]),v._v(" "),d("dt",[v._v("input")]),v._v(" "),d("dd",[v._v("- "),d("em",[v._v("string")]),v._v(", 最后检查字符串。")]),v._v(" "),d("dt",[v._v("source")]),v._v(" "),d("dd",[v._v("- "),d("em",[v._v("string")]),v._v(", 正则表达式的源代码 - 构建该RegExp对象的字符串。")]),v._v(" "),d("dt",[v._v("index")]),v._v(" "),d("dd",[v._v("- "),d("em",[v._v("integer")]),v._v(", 在搜索字符串中第一个成果匹配的字符位置。只读属性。")]),v._v(" "),d("dt",[v._v("lastIndex")]),v._v(" "),d("dd",[v._v("- "),d("em",[v._v("integer")]),v._v(", 在搜索字符串中下一个匹配开始的位置。")]),v._v(" "),d("dt",[v._v("[index]")]),v._v(" "),d("dd",[v._v("- "),d("em",[v._v("string")]),v._v(" | "),d("em",[v._v("undefined")]),v._v(", 只读, 返回第index个匹配片段。"),d("em",[v._v("Index")]),v._v("是一个整数，基于0开始。")]),v._v(" "),d("h2",[v._v("方法")]),v._v(" "),d("dt",[v._v("this")]),v._v(" "),d("dd",[d("p",[d("strong",[v._v("(regular-expresion [,flags])")])]),v._v(" "),d("p",[v._v("用于初始化一个RegExp对象的新实例。"),d("em",[v._v("regular-expresion")]),v._v("是一个字符串-正则表达式的源。"),d("em",[v._v("flags")]),v._v("是一个可选字符串，如果flags中包含"),d("em",[v._v("'i'")]),v._v("字符则进行大小写敏感搜索。如果包含"),d("em",[v._v("'g'")]),v._v("(全局搜索)，则搜索输入字符串中的所有的发生源。"),d("br"),v._v("\n\t  使用方法: "),d("font",{attrs:{face:"monospace"}},[v._v("var re = new RegExp(...);")])],1)]),v._v(" "),d("dt",[v._v("test")]),v._v(" "),d("dd",[d("p",[d("strong",[v._v("(input)")]),v._v(" : "),d("em",[v._v("true")]),v._v(" | "),d("em",[v._v("false")])]),v._v(" "),d("p",[v._v("检查"),d("em",[v._v("input")]),v._v("字符串，如果匹配模式则返回"),d("strong",[v._v("true")]),v._v("，否则返回"),d("strong",[v._v("false")]),v._v("。")])]),v._v(" "),d("dt",[v._v("exec")]),v._v(" "),d("dd",[d("p",[d("strong",[v._v("(input)")]),v._v(" : "),d("em",[v._v("null")]),v._v(" | "),d("em",[v._v("RegExp")]),v._v(" object")]),v._v(" "),d("p",[v._v("如果 "),d("em",[v._v("input")]),v._v(" 存在该模式，则返回这个包含模式匹配集列表和数量的RegExp对象。否则返回"),d("strong",[v._v("null")]),v._v("。")])]),v._v(" "),d("dt",[v._v("positions")]),v._v(" "),d("dd",[v._v("("),d("strong",[v._v("matchIdex")]),v._v(":0... length - 1) : ("),d("em",[v._v("start")]),v._v(":integer, "),d("em",[v._v("end")]),v._v(":integer)\n      "),d("p",[v._v("在执行exec()调用后该方法有效。返回一个整数对 - 输入字符串中被匹配子表达式的开始和结束位置。")])])])])}),[],!1,null,null,null);_.default=o.exports}}]);