(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{366:function(e,n,t){"use strict";t.r(n);var o=t(28),r=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"plus与-formation的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plus与-formation的区别"}},[e._v("#")]),e._v(" +Plus与+Formation的区别")]),e._v(" "),t("h1",{staticClass:"article-title"},[e._v("+plus与+formation的区别?")]),e._v(" "),t("div",{staticClass:"article-content"},[t("h2",[e._v("+plus")]),e._v(" "),t("p",[t("em",[e._v("+plus")]),e._v("是一种定义和支持DOM树和数据树间映射的一种方式。如果你下面这两个声明, HTML:")]),e._v(" "),t("pre",[t("code",[e._v('<style>@import url(plus.css)</style>\n<section model="person">\n  <label>First</label> <input(name.first)>\n  <label>Second</label> <input(name.last)>\n  <label>Age</label> <input|integer(age)>\n</section>')])]),e._v(" "),t("p",[e._v("和脚本：")]),e._v(" "),t("pre",[t("code",[e._v('namespace person {\n  var name = { \n    first: "Albert", \n    last:"Einshtein" \n  }; \n  var age = 53; \n}')])]),e._v(" "),t("p",[e._v("则+plus将构建上面这些DOM元素和数据结构间的双向映射(绑定)。")]),e._v(" "),t("p",[e._v("当用户改变了"),t("code",[e._v("input(name.first)")]),e._v("字段("),t("code",[e._v('<input name="name.first">')]),e._v("简写形式)的value值，则将发生下面这些事情:")]),e._v(" "),t("ol",[t("li",[e._v("Sciter生成“change” DOM事件;")]),e._v(" "),t("li",[e._v("+plus处理这个事件，并且")]),e._v(" "),t("li",[e._v("更新指定数据名称空间中的person.name.first的值。")])]),e._v(" "),t("p",[e._v("当数据被某些代码导致改变时，比如：")]),e._v(" "),t("pre",[t("code",[e._v('person.name.first = "Some other name";')])]),e._v(" "),t("p",[e._v("则将发生下面这些事情:")]),e._v(" "),t("ol",[t("li",[e._v("Sciter首先已经可以检测到这个可观察对象上的"),t("em",[e._v("first")]),e._v("的变化。")]),e._v(" "),t("li",[e._v("Sciter调用附加的函数观察器(function-observer) – 每个绑定到名称空间中的对象/数组都被附加了一个函数观察器。")]),e._v(" "),t("li",[e._v("这个函数观察器将会更新绑定的DOM元素。")])]),e._v(" "),t("p",[e._v("如你所看到的, 为了实现双向绑定, 在绑定的名称空间中每个数据节点(对象/数组)都必须有附加一个对应观察器。")]),e._v(" "),t("h2",[e._v("+formation")]),e._v(" "),t("p",[e._v("+formation与+plus的主要区别是：+formation不需要单独的数据结构。formation生成的数据结构本身就很自然的映射到DOM元素上。")]),e._v(" "),t("p",[e._v("HTML:")]),e._v(" "),t("pre",[t("code",[e._v("<section(person)>\n  <label>First</label> <input(name.first)>\n  <label>Second</label> <input(name.last)>\n  <label>Age</label> <input|integer(age)> \n</section")])]),e._v(" "),t("p",[e._v("调用formation()函数后将会生成[formation]树:")]),e._v(" "),t("p",[t("img",{attrs:{src:"images/formation.png",alt:"",width:"192",height:"109"}})]),e._v(" "),t("p",[e._v("代码可以直接访问这个树，如:")]),e._v(" "),t("pre",[t("code",[e._v('var root = formation( self ); // 生成整个formation: \n// 设置整个formation树:\nroot.person.value = { name : { first: "Albert", last: "Einshtein" }, age:69 }; \n// 设置formation树上的某个特定字段:\nroot.person.name.first.value = "Some other name";')])]),e._v(" "),t("p",[e._v("注意: "),t("code",[e._v("root.person.name.first")]),e._v("是<input>DOM元素的一个直接引用。因此这个DOM元素必须有"),t("code",[e._v(".value")]),e._v("属性。")]),e._v(" "),t("p",[e._v("这个formation是一个从真实DOM树上派生出来的数据结构，所以你可以通过点语句直接在这个DOM元素上绑定DOM事件来处理用户操作:")]),e._v(" "),t("pre",[t("code",[e._v('root.person.name.first.on("change", function() {...}) // 或者 \nself.on("change", "section[name=person]", function() {...}) // person字段的任何改变')])]),e._v(" "),t("h2",[e._v("总结")]),e._v(" "),t("p",[e._v("本质上，+plus和+formation都是做相同事情的 – 根据代码更新UI/UI改变时通知代码。")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("+plus")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("pros:")]),e._v("允许将任意的数据结构绑定到任意的DOM树上。")]),e._v(" "),t("li",[t("strong",[e._v("cons:")]),e._v("在大数据和DOM树上，可能会有比较到的内存和CPU消耗。")])])]),e._v(" "),t("li",[t("strong",[e._v("+formation")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("pros:")]),e._v("速度快，CPU消耗小。 并且可以通过点语句(“formation中的路径”)访问“感兴趣的字段”: "),t("code",[e._v("root.person.name.first.state.disabled = true;")])]),e._v(" "),t("li",[t("strong",[e._v("cons:")]),e._v("得到的formation数据结构是直接绑定到DOM元素上的。所以当你改变的DOM结构时，在代码中的formation路径需要改变。")])])])])])])}),[],!1,null,null,null);n.default=r.exports}}]);