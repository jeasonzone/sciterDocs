(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{292:function(t,e,n){"use strict";n.r(e);var r=n(28),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"装饰器-函数、类和名称空间的装饰器"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#装饰器-函数、类和名称空间的装饰器"}},[t._v("#")]),t._v(" 装饰器(函数、类和名称空间的装饰器)")]),t._v(" "),n("div",{staticClass:"level1"},[n("h2",[n("a",{attrs:{id:"introduction",name:"introduction"}},[t._v("简介")])]),t._v(" "),n("div",{staticClass:"level2"},[n("p",[t._v("装饰器 "),n("sup",[n("a",{staticClass:"fn_top",attrs:{id:"fnt__1",href:"#fn__1",name:"fnt__1"}},[t._v("1)")])]),t._v("是一个元编程特征。一个装饰器是一个函数，它用于修改另一个函数或方法。通常，装饰器函数创建另一个函数封装(装饰)原始的函数调用，以便做一些预先或扫尾处理。在TIScript中, 装饰器是一个普通函数，它接受一个后多个参数。第一个参数总是要装饰的对象(函数、类或名称空间)的引用。装饰器的函数名称应该以@字符开头。这里是一个@returns装饰器的示例。这个装饰器创建一个代理函数，它校验被装饰函数的返回值是否符合预期:")]),t._v(" "),n("pre",{pre:!0,attrs:{class:"code tiscript"}},[n("code",[t._v("function @returns(func, return_type)\n{\n  return function(params..) // 'func'的return代理函数\n  {\n    var rv = func.apply(this, params); // 调用'func'函数\n    if( typeof rv != return_type )     // 校验它的返回值类型\n      throw String.printf(\"Function %s expected to return %s but got %s\",\n                           func.name, return_type, typeof rv);\n    return rv;\n  }\n}\n")])]),t._v(" "),n("p",[t._v("当某函数使用了该装饰器，它能确保该函数的返回值是预期的类型:")]),t._v(" "),n("pre",{pre:!0,attrs:{class:"code tiscript"}},[n("code",[t._v("@returns #integer\nfunction SumInt(a, b)\n{\n  return a + b;\n}\n")])])]),t._v(" "),n("h2",[n("a",{attrs:{id:"syntax-of-decorator-invocation",name:"syntax-of-decorator-invocation"}},[t._v("装饰器的调用语法")])]),t._v(" "),n("div",{staticClass:"level2"},[n("p",[t._v("TIScript的核心语法已经支持为函数和方法添加装饰器。要添加装饰器，语法类似下面:")]),t._v(" "),n("pre",{pre:!0,attrs:{class:"code"}},[n("code",[t._v("[<装饰器-列表>] "),n("code",[t._v("function")]),t._v(" <函数名> "),n("code",[t._v("(")]),t._v(" <参数> "),n("code",[t._v(")")]),t._v(" "),n("code",[t._v("{")]),t._v(" <函数体> "),n("code",[t._v("}")]),t._v(" -- 命名函数;\n[<装饰器-列表>] "),n("code",[t._v(":")]),t._v(" <参数> "),n("code",[t._v(":")]),t._v(" <语句> -- 匿名语句;\n[<装饰器-列表>] "),n("code",[t._v(":")]),t._v(" <参数> "),n("code",[t._v("{")]),t._v(" <函数体> "),n("code",[t._v("}")]),t._v(" -- 匿名函数\n")])]),t._v(" "),n("p",[t._v("其中，装饰器-列表是一个或多个装饰器调用列表。每个装饰器调用由一个装饰器函数的名称(以'@'开头)和一个可选的供装饰器调用的以空格分隔参数值列表组成。")]),t._v(" "),n("pre",{pre:!0,attrs:{class:"code"}},[n("code",[t._v("@装饰器名称 [p1 [p2 [... pN ]]] <函数或匿名声明>\n")])])]),t._v(" "),n("h3",[n("a",{attrs:{id:"empty-decorator",name:"empty-decorator"}},[t._v("空装饰器")])]),t._v(" "),n("div",{staticClass:"level3"},[n("p",[t._v("有时，你可能需要使用一个空装饰器，如创建一些函数而不是装饰另一个函数时。装饰器末尾以;(分号)结尾:")]),t._v(" "),n("pre",{pre:!0,attrs:{class:"code"}},[n("code",[t._v("@装饰器名 [p1 [p2 [... pN ]]] ;\n")])])]),t._v(" "),n("h2",[n("a",{attrs:{id:"the-decorator-function",name:"the-decorator-function"}},[t._v("装饰器函数")])]),t._v(" "),n("div",{staticClass:"level2"},[n("p",[t._v("若一个函数被当做装饰器使用，则它的函数名称必须以@字符开头。")]),t._v(" "),n("p",[t._v("装饰器函数必须至少有一个参数。这个参数将是被装饰对象的引用。")]),t._v(" "),n("p",[t._v("装饰器函数是一个普通函数，即它可以被当做普通函数那样使用。")])]),t._v(" "),n("h3",[n("a",{attrs:{id:"this",name:"this"}},[t._v("this")])]),t._v(" "),n("div",{staticClass:"level3"},[n("p",[t._v("在装饰器中，this环境变量是装饰器被应用处的当前名称空间/类。如果装饰器被应用在一个全局函数，则this是全局名称空间对象的引用。")]),t._v(" "),n("h2",[t._v("装饰器使用示例")]),t._v(" "),n("p",[t._v("这里是ScIDE源代码的一个片段:")]),t._v(" "),n("pre",{pre:!0},[n("code",[t._v("@key 'N' @CTRL @NOSHIFT @NOALT : { openFile(); return true; } // Ctrl+N\n@key 'S' @CTRL @SHIFT @NOALT : { saveAllDocuments(); return true; } // Ctrl+Shift+S\n")])]),t._v(" "),n("p",[t._v("这两行代码为self.onKey事件(见下面的function @key()声明)添加事件处理器(右边的匿名方法)。@CTRL、@SHIFT和@NOALT也是装饰器，它们为调用链上的事件处理器代码末尾添加自己的过滤表达式。")]),t._v(" "),n("p",[t._v("这里说明这些装饰器是如何实现的:")]),t._v(" "),n("pre",{pre:!0},[n("code",[t._v("// '@key'装饰器 - 根据keyCode和ctrl, shift, alt标志过滤Event.KEY_DOWN事件\n// 在onKey中建立事件处理器链\nfunction "),n("code",[t._v("@key")]),t._v("(func, keyCode = undefined, modifiers..)\n{\n  function t(evt)\n  {\n    var r = false;\n    if( evt.type == Event.KEY_DOWN &&\n        (keyCode === undefined || (keyCode == evt.keyCode)) )\n          r = func.call(this,evt);\n    if(t.next) return t.next.call(this,evt) || r;\n    return r;\n  }\n  // 注意，在装饰器中的‘this’是当前名称空间 -类 或 全局(ns)\n  var principal = this instanceof Behavior ? this : self;\n  t.next = principal.onKey;\n  principal.onKey = t;\n}\n// '@CTRL'装饰器 - 如果 evt.ctrlKey === true则通过\nfunction "),n("code",[t._v("@CTRL")]),t._v("(func) { return function(evt) { if( evt.ctrlKey === true ) return func.call(this,evt); } }\n// '@NOCTRL'装饰器 - 如果 evt.ctrlKey === false则通过\nfunction "),n("code",[t._v("@NOCTRL")]),t._v("(func) { return function(evt) { if( evt.ctrlKey === false ) return func.call(this,evt); } }\n")])]),t._v(" "),n("hr")]),t._v(" "),n("div",{staticClass:"footnotes"},[n("div",[n("sup",[n("a",{staticClass:"fn_bot",attrs:{id:"fn__1",href:"#fnt__1",name:"fn__1"}},[t._v("1)")])]),t._v("TIScript中的装饰器参考了"),n("a",{staticClass:"urlextern",attrs:{title:"http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators",href:"http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators",rel:"nofollow"}},[t._v("Python中的装饰器")]),t._v("编程语言。")])])])])}),[],!1,null,null,null);e.default=v.exports}}]);