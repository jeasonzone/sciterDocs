(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{284:function(e,v,_){"use strict";_.r(v);var t=_(28),r=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"await和promise"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#await和promise"}},[e._v("#")]),e._v(" await和promise")]),e._v(" "),_("h1",[_("a",{attrs:{href:"http://promises-aplus.github.io/promises-spec"}},[e._v("Promises/A+规范")]),e._v("的实现")]),e._v(" "),_("h2",[e._v("promise()函数")]),e._v(" "),_("p",[_("code",[e._v("promise()")]),e._v("函数返回一个可调用的对象(函数)，它有一个"),_("code",[e._v(".then(onFulfilled, onRejected)")]),e._v("方法。")]),e._v(" "),_("p",[e._v("promise可以有以下几种创建方式：")]),e._v(" "),_("p",[e._v("("),_("strong",[e._v("方式#1")]),e._v(")")]),e._v(" "),_("pre",{pre:!0},[_("code",[e._v("var prom = promise();")])]),e._v(" "),_("p",[e._v("("),_("strong",[e._v("方式#2")]),e._v(")")]),e._v(" "),_("pre",{pre:!0},[_("code",[e._v("var prom = promise( function( "),_("em",[e._v("resolve")]),e._v(":function, "),_("em",[e._v("reject")]),e._v(":function ) {...} );\n")])]),e._v(" "),_("h3",[e._v("履行/解决 诺言(promise)：")]),e._v(" "),_("p",[e._v("调用它的"),_("code",[e._v("prom(")]),_("u",[_("code",[e._v("true")])]),_("code",[e._v(", params)")]),e._v("方法。其中，"),_("em",[e._v("params")]),e._v("是将传递给onFulfilled回调函数("),_("code",[e._v(".then()")]),e._v("方法注册)的参数数组。")]),e._v(" "),_("h3",[e._v("拒绝 诺言(promise)：")]),e._v(" "),_("p",[e._v("调用它的"),_("code",[e._v("prom(")]),_("u",[_("code",[e._v("false")])]),_("code",[e._v(", params)")]),e._v("方法。其中，"),_("em",[e._v("params")]),e._v("是将传递给onRejected回调函数("),_("code",[e._v(".then()")]),e._v("方法注册)的参数数组。")]),e._v(" "),_("h3",[e._v("解决或拒绝诺言(promise)：")]),e._v(" "),_("p",[e._v("只需在你的函数体里调用"),_("em",[e._v("resolve")]),e._v("(result)或"),_("em",[e._v("reject(error)")]),e._v("回调函数。")]),e._v(" "),_("h2",[e._v("Promise的方法")]),e._v(" "),_("p",[_("code",[e._v("promise()")]),e._v("函数返回一个函数对象，它有以下几个方法:")]),e._v(" "),_("dl",[_("dt",[e._v("promise.then")]),e._v(" "),_("dd",[_("strong",[e._v("(onFulfilled")]),e._v(" : function(data) [, "),_("strong",[e._v("onRejected")]),e._v(": function(err) ] "),_("strong",[e._v(")")]),e._v(" : "),_("em",[e._v("promise")]),e._v(" "),_("p",[e._v("给promise绑定履行(fulfillment)和拒绝(rejection)处理器/回调函数, 并且返回一个新的promise。 绑定的处理器会在诺言(promise)完成时被调用。")])]),e._v(" "),_("dt",[e._v("promise.catch")]),e._v(" "),_("dd",[_("strong",[e._v("(onError")]),e._v(": function(err) "),_("strong",[e._v(")")]),e._v(" : "),_("em",[e._v("promise")]),e._v(" "),_("p",[e._v("给promise添加拒绝(rejection)处理器, 并且返回一个新的promise。")])]),e._v(" "),_("dt",[e._v("promise.finally")]),e._v(" "),_("dd",[_("strong",[e._v("(onResolved")]),e._v(": function(dataOrErr) "),_("strong",[e._v(")")]),e._v(" : "),_("em",[e._v("promise")]),e._v(" "),_("p",[e._v('给promise添加"履行(resolved)"处理器，并且返回一个新的promise。 这个处理器会在诺言(promise)完成时被调用，不管诺言是成功还是失败。')])]),e._v(" "),_("dt",[e._v("promise.when")]),e._v(" "),_("dd",[_("strong",[e._v("( promise1, promise2, promise3, ... )")]),e._v(" : "),_("em",[e._v("promise")]),e._v(" "),_("p",[e._v("静态方法, 返回一个新的promise，它会等所有参数中的诺言履行后才被履行。如果参数中的某一个诺言被拒绝，则它也会被拒绝。")])])]),e._v(" "),_("h2",[e._v("重定义的View/Element.request()函数")]),e._v(" "),_("p",[_("em",[e._v("promise.tis")]),e._v("也重定义了Element.request()方法 - http get/post/put/delete调用。所以在包含此模块的情况下，Element.request()可以按以下形式被调用:")]),e._v(" "),_("ol",[_("li",[_("strong",[e._v("element.request(")]),e._v(" "),_("strong",[e._v("callback")]),e._v(": function, "),_("strong",[e._v("httpcmd ")]),e._v(", "),_("strong",[e._v("url")]),e._v(": string [, "),_("strong",[e._v("params")]),e._v(": object [, "),_("strong",[e._v("headers")]),e._v(": object] ] "),_("strong",[e._v(") ")]),e._v(": true | false"),_("br"),e._v("- 异步请求，服务器响应信息传递到callback函数。")]),e._v(" "),_("li",[_("strong",[e._v("element.request(")]),e._v(" "),_("strong",[e._v("timeout")]),e._v(": integer, "),_("strong",[e._v("httpcmd ")]),e._v(", "),_("strong",[e._v("url")]),e._v(": string [, "),_("strong",[e._v("params")]),e._v(": object [, "),_("strong",[e._v("headers")]),e._v(": object] ] "),_("strong",[e._v(") ")]),e._v(": (data, status)"),_("br"),e._v("- 同步请求，服务器响应信息作为第一个返回值，http状态码作为第二个返回值。")]),e._v(" "),_("li",[_("strong",[e._v("element.request(")]),e._v(" "),_("strong",[e._v("httpcmd ")]),e._v(", "),_("strong",[e._v("url")]),e._v(": string [, "),_("strong",[e._v("params")]),e._v(": object [, "),_("strong",[e._v("headers")]),e._v(": object] ] "),_("strong",[e._v(") ")]),e._v(": promise,"),_("br"),e._v("- 异步请求，服务器的响应信息传递到promise调用"),_("code",[e._v(".then(onsuccess,onfailure)")]),e._v("注册的onsuccess回调函数上。")]),e._v(" "),_("li",[_("strong",[e._v("view.request(")]),e._v(" "),_("strong",[e._v("params")]),e._v(": map  "),_("strong",[e._v(") ")]),e._v(": "),_("strong",[e._v("promise")]),e._v(","),_("br"),e._v("- 异步请求，服务器的响应信息传递到promise调用"),_("code",[e._v(".then(onsuccess,onfailure)")]),e._v("注册的onsuccess回调函数上。")])]),e._v(" "),_("h2",[e._v("promise() 与 await")]),e._v(" "),_("p",[_("code",[e._v("await")]),e._v("操作符可以避免使用诺言方式的回调，而是使用线性的方式来写异步代码:")]),e._v(" "),_("pre",{pre:!0},[_("code",[e._v("async function getRemoteTexts(url)\n{\n  try {\n    var text = "),_("u",[e._v("await")]),e._v(' view.request { url: url, output: #string };\n    stdout.println("完成:", text);\n  } catch(e) {\n    stdout.println("出错:", e);\n  }\n}\n// 启动一个任务:\ngetRemoteTexts("http://sciter.com/test/text.txt");\nstdout.println("任务开始");\n')])]),e._v(" "),_("p",[e._v("当你在Sciter中运行这段代码片段时，你会在控制台看到以下输出内容:")]),e._v(" "),_("pre",{pre:!0},[_("code",[e._v("> 任务开始\n> 完成: {content of test/text.txt file }\n")])]),e._v(" "),_("p",[e._v('"> 任务开始" 将会首先出现。任何包含'),_("em",[e._v("await")]),e._v("的函数都会自动转换成一个Task函数。")]),e._v(" "),_("p",[e._v("Task函数的调用将会立即完成，而它的函数体将会在队列里稍后执行。")]),e._v(" "),_("p",[e._v("当执行到"),_("em",[e._v("await")]),e._v("语句时，它后面的语句将会推迟到"),_("em",[e._v("view.request")]),e._v("完成(诺言解决)后再继续执行。")]),e._v(" "),_("p",[e._v("也就是说: await是另一种等待诺言被解决的方式。")])])}),[],!1,null,null,null);v.default=r.exports}}]);