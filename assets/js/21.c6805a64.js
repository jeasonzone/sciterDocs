(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{218:function(t,e,s){t.exports=s.p+"assets/img/wth.ddf3ef0f.png"},344:function(t,e,s){"use strict";s.r(e);var i=s(28),a=Object(i.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"sciter的ui设计基本原则"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#sciter的ui设计基本原则"}},[t._v("#")]),t._v(" Sciter的UI设计基本原则")]),t._v(" "),i("div",{staticClass:"post",attrs:{id:"post-41772"}},[i("h1",{staticClass:"storytitle"},[t._v("Sciter UI的基本设计原则。调用UI背后的工作线程中的代码。")])]),t._v(" "),i("div",{staticClass:"storycontent"},[i("p",[t._v("我在SDK中添加了新的示例: /sdk/demos/ui-framework。"),i("br"),t._v(" \n   这个示例演示了"),i("a",{attrs:{href:"Sciter-UI-application-architecture.htm",title:"Sciter UI及它的应用架构"}},[t._v("“Sciter UI及它的应用架构”")]),t._v("文章中描述的设计原则。")]),t._v(" "),i("p",[i("a",{attrs:{href:"../imgs/wth.png"}},[i("img",{staticClass:"aligncenter size-full wp-image-41773",attrs:{src:s(218),alt:"Sciter demo screenshot",width:"629",height:"648"}})])]),t._v(" "),i("p",[t._v("这个示例演示了怎么定义一个本地函数(view.execTask() -> window::exec_task())，以及如何从工作线程中调用UI方法(通过回调)。")]),t._v(" "),i("p",[t._v("我已经在"),i("a",{attrs:{href:"http://www.terrainformatica.com/2011/01/c0x-running-code-in-gui-thread-from-worker-threads/"}},[t._v("这篇文章")]),t._v("中解释了如何在工作线程中调用UI，不过在这个示例里，我使用了一种稍微不同的机制。")]),t._v(" "),i("p",[t._v("gui_exec函数看起来类似这样的:")]),t._v(" "),i("pre",{staticClass:"brush: cpp;"},[i("code",[t._v("// 这个函数被工作线程调用，用于执行GUI线程中gui_block \ninline void gui_exec( std::function<void()> gui_block )\n{\n  sciter::sync::event evt;\n  PostThreadMessage(gGUIThreadId, WM_EXEC, WPARAM(&evt),LPARAM(&gui_block));\n  evt.wait(); // 暂停工作线程，直到GUI线程执行完毕gui_block。\n}")]),t._v("\n")]),t._v(" "),i("p",[t._v("它将消息post到GUI线程的消息队列中，WM_EXEC消息的接收者是是Windows的WH_GETMESSAGE的hook函数:")]),t._v(" "),i("pre",{staticClass:"brush: cpp;"},[i("code",[t._v("// message hook to handle WM_EXEC in GUI thread\nstatic LRESULT CALLBACK gui_exec_hook_GetMsgProc(int code, WPARAM wParam, LPARAM lParam )\n{\n  MSG* pmsg = reinterpret_cast<MSG*>(lParam);\n  if(pmsg->message == WM_EXEC)\n  {\n    sciter::sync::event* pe = reinterpret_cast<sciter::sync::event*>(pmsg->wParam);\n    gui_block* pf = reinterpret_cast<gui_block*>(pmsg->lParam);\n    (*pf)();      // execute the block in this GUI thread\n    pe->signal(); // signal that we've done with it\n                  // this will resume execution of worker thread.\n  }\n  return CallNextHookEx(0,code, wParam,lParam);\n}")])]),t._v(" "),i("p",[t._v("Using hooks allows this mechanism to work reliably even when application is running modal dialog loops.")])])])}),[],!1,null,null,null);e.default=a.exports}}]);